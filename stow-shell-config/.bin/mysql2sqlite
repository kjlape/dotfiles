#!/usr/bin/env ruby

require 'optparse'

class MySQL2SQLiteConverter
  def initialize
    @current_table = ''
    @keys = []
  end

  def convert(mysql_content)
    sqlite = <<~HEADER
      -- import to SQLite by running: sqlite3.exe db.sqlite3 -init sqlite.sql

      PRAGMA journal_mode = MEMORY;
      PRAGMA synchronous = OFF;
      PRAGMA foreign_keys = OFF;
      PRAGMA ignore_check_constraints = OFF;
      PRAGMA auto_vacuum = NONE;
      PRAGMA secure_delete = OFF;
      BEGIN TRANSACTION;

    HEADER

    lines = mysql_content.split("\n")
    skip_patterns = [
      /^CREATE DATABASE/i,
      /^USE/i,
      /^\/\*/i,
      /^--/i,
      /^SET /i,
      /^START TRANSACTION/i,
      /^COMMIT/i,
      /^LOCK TABLES/i,
      /^UNLOCK TABLES/i
    ]

    # Track tables and their columns for index validation
    table_columns = {}
    current_create_table = false

    lines.each do |line|
      line = line.strip

      # Skip lines that match patterns in skip_patterns array
      next if skip_patterns.any? { |pattern| pattern.match?(line) }

      # Handle ALTER TABLE statements
      if line.match?(/^ALTER TABLE/i)
        # Skip standalone ALTER TABLE statements without table name
        next if !line.match?(/ALTER TABLE\s+[`"]([^`"]+)[`"]/i)
        
        # Extract the table name
        table_name = line.match(/ALTER TABLE\s+[`"]([^`"]+)[`"]/i)[1]
        
        # Handle complex ALTER TABLE statements with multiple ADD PRIMARY KEY clauses
        if line.match?(/ADD PRIMARY KEY|ADD UNIQUE KEY|ADD KEY/i)
          # Process each ADD PRIMARY/UNIQUE/KEY clause separately
          line.scan(/ADD\s+(PRIMARY KEY|UNIQUE KEY|KEY)\s+(?:[`"]([^`"]+)[`"])?\s*\(([^)]+)\)/i) do |key_type, key_name, columns|
            key_name ||= "pk_#{table_name}"
            columns = columns.gsub(/[`"]/i, '')
            
            if key_type == "PRIMARY KEY"
              sqlite += "CREATE UNIQUE INDEX IF NOT EXISTS `pk_#{table_name}` ON `#{table_name}` (#{columns});\n"
            elsif key_type == "UNIQUE KEY"
              sqlite += "CREATE UNIQUE INDEX IF NOT EXISTS `#{key_name}` ON `#{table_name}` (#{columns});\n"
            else
              sqlite += "CREATE INDEX IF NOT EXISTS `#{key_name}` ON `#{table_name}` (#{columns});\n"
            end
          end
        elsif line.match?(/MODIFY/i)
          # Extract column name from MODIFY statement for potential column addition
          if (match = line.match(/MODIFY\s+[`"]([^`"]+)[`"]/i))
            column_name = match[1]
            column_type = "TEXT" # Default type
            
            # Try to extract the type
            if line.match?(/INTEGER|TEXT|REAL|BLOB|NULL/i)
              column_type = line.match(/(INTEGER|TEXT|REAL|BLOB|NULL)/i)[1]
            end
            
            # Add column if it doesn't exist (will be checked later)
            missing_columns[table_name] ||= []
            missing_columns[table_name] << [column_name, column_type]
          end
        end
        next
      end

      # Include all INSERT lines. Replace \' by '' and handle X'...' hex literals
      if line.match?(/^(INSERT|\()/i)
        # Fix X'...' hex literals by ensuring they're properly formatted
        # First, handle the common pattern of dimensions like 15X'150' or 30X'225'
        line = line.gsub(/(\d+)X'(\d+)'/) do |match|
          "#{$1}X#{$2}" # Convert 15X'150' to 15X150
        end
        
        # Handle email addresses with X'...' patterns before general X'...' processing
        line = line.gsub(/([a-zA-Z0-9._%+-]+)X'([^']+)'@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/) do |match|
          "#{$1}#{$2}@#{$3}" # Convert emailX'part'@domain.com to emailpart@domain.com
        end
        
        # Handle single character X'...' literals that cause problems
        line = line.gsub(/X'([A-Za-z0-9])'/) do |match|
          "'#{$1}'" # Convert X'A' to 'A'
        end
        
        # Handle multi-character non-hex X'...' literals
        line = line.gsub(/X'([^']*[^0-9A-Fa-f][^']*)'/) do |match|
          "'#{$1.gsub("'", "''")}'" # Convert X'abc' to 'abc'
        end
        
        # Then handle any remaining X'...' literals (should be valid hex now)
        line = line.gsub(/X'([0-9A-Fa-f]+)'/) do |match|
          match # Keep valid hex literals
        end
        
        # Handle other string escaping
        line = line.gsub(/\\'/i, "''")
        
        sqlite += line + "\n"
        next
      end

      # Print the CREATE line as is and capture the table name
      if (match = line.match(/^\s*CREATE TABLE.*[`"](.*)[`"]/i))
        @current_table = match[1]
        current_create_table = true
        table_columns[@current_table] = []
        sqlite += "\n" + line + "\n"
        next
      end

      # Clean table end line
      if line.start_with?(")") && !line.include?("(")
        current_create_table = false
        sqlite += ");\n"
        next
      end

      # Collect column names during CREATE TABLE
      if current_create_table && (match = line.match(/^\s*[`"]([^`"]+)[`"]/))
        column_name = match[1]
        table_columns[@current_table] << column_name unless column_name.nil?
      end

      # Remove CONSTRAINT part from lines
      line = line.gsub(/^CONSTRAINT [`'"][\w]+[`'"][\s]+/i, '')

      # Replace "XXXXX KEY" by "KEY" except "PRIMARY KEY" "FOREIGN KEY" and "UNIQUE KEY"
      line = line.gsub(/^(?!FOREIGN)(?!PRIMARY)(?!UNIQUE)\w+\s+KEY/i, 'KEY')

      # Extract KEY lines for later processing
      if (match = line.match(/^(UNIQUE\s+)?KEY\s+[`'"](\w+)[`'"]\s+\([`'"](\w+)[`'"]/i))
        key_unique = match[1] || ""
        key_name = match[2]
        col_name = match[3]
        @keys << "CREATE #{key_unique}INDEX IF NOT EXISTS `#{@current_table}_#{key_name}` ON `#{@current_table}` (`#{col_name}`);"
        next
      end

      # Process field definition lines (not KEY lines and not lines starting with ")")
      if line.match?(/^[^)]((?![\w]+\sKEY).)*$/i)
        # Clear invalid keywords
        line = line.gsub(/AUTO_INCREMENT|CHARACTER SET [^ ]+|UNSIGNED/i, "")
        line = line.gsub(/DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP|COLLATE [^ ]+/i, "")
        line = line.gsub(/COMMENT\s['"`].*['"`]/i, "")
        line = line.gsub(/SET\([^)]+\)|ENUM[^)]+\)/i, "TEXT ")

        # Clear MySQL-specific types
        line = line.gsub(/int\([0-9]*\)/i, "INTEGER")
        line = line.gsub(/bigint\([0-9]*\)/i, "INTEGER")
        line = line.gsub(/varchar\([0-9]*\)|LONGTEXT/i, "TEXT")
        line = line.gsub(/datetime/i, "TEXT")
        line = line.gsub(/timestamp/i, "TEXT")
      end

      sqlite += line + "\n" unless line.empty?
    end

    sqlite += "\n"

    # Fix last table line with comma
    sqlite = sqlite.gsub(/,\n\);/, "\n);")

    # Filter out keys for columns that don't exist in their tables
    valid_keys = @keys.select do |key_statement|
      if (match = key_statement.match(/ON\s+`([^`]+)`\s+\(`([^`]+)`\)/i))
        table_name = match[1]
        column_name = match[2]
        
        # Only include keys for columns that exist in their tables
        table_columns.key?(table_name) && table_columns[table_name].include?(column_name)
      else
        true # Keep keys we couldn't parse
      end
    end
    
    # Initialize missing_columns hash if not already done
    missing_columns ||= {}
    
    # Find INSERT statements and extract table and column names
    sqlite.scan(/INSERT INTO [`"]([^`"]+)[`"]\s*\(([^)]+)\)/i) do |table_name, columns_str|
      columns = columns_str.split(',').map { |col| col.gsub(/[`"\s]/i, '') }
      
      if table_columns.key?(table_name)
        # Find columns that are in the INSERT but not in the CREATE TABLE
        missing = columns.select { |col| !table_columns[table_name].include?(col) }
        
        if !missing.empty?
          missing_columns[table_name] ||= []
          missing_columns[table_name].concat(missing.map { |col| [col, "TEXT"] })
          missing_columns[table_name].uniq!
        end
      end
    end
    
    # Add specific columns that are known to cause issues
    ["wp_actionscheduler_actions", "wp_actionscheduler_logs"].each do |table|
      if table_columns.key?(table) && !table_columns[table].include?("group_id")
        missing_columns[table] ||= []
        missing_columns[table] << ["group_id", "INTEGER"]
      end
    end
    
    ["wp_aioseo_posts"].each do |table|
      if table_columns.key?(table) && !table_columns[table].include?("description")
        missing_columns[table] ||= []
        missing_columns[table] << ["description", "TEXT"]
      end
    end
    
    # Add ALTER TABLE statements to add missing columns
    missing_columns.each do |table_name, columns|
      columns.each do |column_info|
        column_name = column_info.is_a?(Array) ? column_info[0] : column_info
        column_type = column_info.is_a?(Array) ? column_info[1] : "TEXT"
        
        # Skip if column already exists in the table
        next if table_columns[table_name]&.include?(column_name)
        
        sqlite += "ALTER TABLE `#{table_name}` ADD COLUMN `#{column_name}` #{column_type};\n"
        
        # Add to table_columns to prevent duplicate ALTER statements
        table_columns[table_name] ||= []
        table_columns[table_name] << column_name
      end
    end

    # Include all valid gathered keys as CREATE INDEX
    sqlite += "\n\n" + valid_keys.join("\n") + "\n\n"

    # Re-enable foreign key check
    sqlite += <<~FOOTER
      COMMIT;
      PRAGMA ignore_check_constraints = ON;
      PRAGMA foreign_keys = ON;
      PRAGMA journal_mode = WAL;
      PRAGMA synchronous = NORMAL;
    FOOTER

    # Replace hex values
    sqlite = sqlite.gsub(/0x([0-9A-Fa-f]+)/i, "X'\\1'")
    
    # Final cleanup pass for any remaining problematic patterns
    
    # Fix dimension patterns like 15X'150' that might have been missed
    sqlite = sqlite.gsub(/(\d+)X'(\d+)'/) do |match|
      "#{$1}X#{$2}" # Convert 15X'150' to 15X150
    end
    
    # Fix email addresses with X'...' patterns
    sqlite = sqlite.gsub(/([a-zA-Z0-9._%+-]+)X'([^']+)'@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/) do |match|
      "#{$1}#{$2}@#{$3}" # Convert emailX'part'@domain.com to emailpart@domain.com
    end
    
    # Handle single character X'...' literals that cause problems
    sqlite = sqlite.gsub(/X'([A-Za-z0-9])'/) do |match|
      "'#{$1}'" # Convert X'A' to 'A'
    end
    
    # Handle multi-character non-hex X'...' literals
    sqlite = sqlite.gsub(/X'([^']*[^0-9A-Fa-f][^']*)'/) do |match|
      "'#{$1.gsub("'", "''")}'" # Convert X'abc' to 'abc'
    end
    
    # Fix any standalone ALTER TABLE ADD PRIMARY KEY statements
    sqlite = sqlite.gsub(/^ADD PRIMARY KEY/, "-- Skipped: ADD PRIMARY KEY")
    sqlite = sqlite.gsub(/^ADD UNIQUE KEY/, "-- Skipped: ADD UNIQUE KEY")
    
    # Fix any standalone MODIFY statements
    sqlite = sqlite.gsub(/^MODIFY/, "-- Skipped: MODIFY")

    sqlite
  end
end

def main
  options = {}
  
  OptionParser.new do |opts|
    opts.banner = "Usage: mysql2sqlite.rb [options] [input_file]"
    opts.separator ""
    opts.separator "MySQL to SQLite SQL converter"
    opts.separator ""
    opts.separator "Options:"

    opts.on("-i", "--input FILE", "Input MySQL SQL file") do |file|
      options[:input] = file
    end

    opts.on("-o", "--output FILE", "Output SQLite SQL file") do |file|
      options[:output] = file
    end

    opts.on("-h", "--help", "Show this help message") do
      puts opts
      exit
    end

    opts.on("--version", "Show version") do
      puts "MySQL to SQLite Ruby CLI v1.0.0"
      puts "Converted from: https://github.com/ww9/mysql2sqlite"
      exit
    end
  end.parse!

  # Handle input file from arguments if not specified with -i
  if ARGV.length > 0 && !options[:input]
    options[:input] = ARGV[0]
  end

  # Read input
  mysql_content = if options[:input]
    unless File.exist?(options[:input])
      STDERR.puts "Error: Input file '#{options[:input]}' not found"
      exit 1
    end
    File.read(options[:input])
  else
    if STDIN.tty?
      STDERR.puts "Error: No input provided. Use -i FILE or pipe input to stdin"
      STDERR.puts "Run with -h for help"
      exit 1
    end
    STDIN.read
  end

  # Convert
  converter = MySQL2SQLiteConverter.new
  sqlite_content = converter.convert(mysql_content)

  # Write output
  if options[:output]
    File.write(options[:output], sqlite_content)
    puts "Converted MySQL to SQLite. Output written to: #{options[:output]}"
  else
    puts sqlite_content
  end

rescue StandardError => e
  STDERR.puts "Error: #{e.message}"
  exit 1
end

if __FILE__ == $0
  main
end
